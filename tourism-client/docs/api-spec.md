# 接口模块设计说明

## 1. 用户中心模块 (Identity & Access)
负责用户的身份识别与基本信息维护。

| 功能名称 | 接口路径 | 请求方法 | 关键逻辑说明 |
|---|---|---|---|
| 用户注册 | /auth/register | POST | 密码需进行 BCrypt 加密存储。 |
| 密码登录 | /auth/login | POST | 校验通过后发放 JWT，后续请求需携带在 Header 中。 |
| 获取个人资料 | /user/profile | GET | 包含昵称、头像、发布的日记数等汇总信息。 |
| 修改个人资料 | /user/profile | PUT | 允许修改昵称、头像及个人简介。 |

## 2. 景点探索模块 (Travel Spots)
平台的核心内容资产，侧重于查询效率。

| 功能名称 | 接口路径 | 请求方法 | 关键逻辑说明 |
|---|---|---|---|
| 获取景点列表 | /spots | GET | 核心接口：支持分页。sort_strategy 参数目前默认为“时间倒序”，预留“推荐”扩展位。 |
| 景点详情查询 | /spots/{id} | GET | 从 Redis 获取缓存数据，若失效则穿透至 DB 并回填缓存。 |
| 景点搜索 | /spots/search | GET | 支持按名称、城市关键字进行模糊匹配。 |

## 3. 旅行日记与互动模块 (Social & Interaction)
用户生产内容 (UGC) 的核心，强调社交属性。

| 功能名称 | 接口路径 | 请求方法 | 关键逻辑说明 |
|---|---|---|---|
| 发布旅行日记 | /diaries | POST | 支持上传图片 URL 列表，可关联特定景点。 |
| 日记详情/广场 | /diaries | GET | 默认按时间流展示。支持按“最热”排序（基于点赞/评论数）。 |
| 我的日记管理 | /diaries/me | GET | 方便用户管理自己发布的内容。 |
| 发表评论 | /comments | POST | 通用接口：需传 targetType (景点或日记) 和 targetId。 |
| 查看评论区 | /comments | GET | 树状或扁平化展示某内容下的所有评论。 |
| 删除内容 | /diaries/{id} | DELETE | 需严格校验“本人操作”或“管理员操作”。 |

## 4. 后台管理模块 (Management & Analytics)
仅限具有 ADMIN 权限的人员，负责维护平台秩序和数据分析。

### A. RBAC 权限管理
| 功能名称 | 接口路径 | 请求方法 | 核心逻辑 |
|---|---|---|---|
| 用户账号管控 | /admin/users | GET/PUT | 查看全量用户，支持“禁用/启用”账号。 |
| 角色分配 | /admin/users/{id}/roles | PUT | 为特定用户赋予/撤销角色（如：审核员、运营、超级管理员）。 |

### B. 内容运维
| 功能名称 | 接口路径 | 请求方法 | 核心逻辑 |
|---|---|---|---|
| 景点资料维护 | /admin/spots | POST/PUT/DELETE | 实现景点的增删改。 |
| 内容审核流 | /admin/audit/list | GET | 待审核列表，集中处理用户举报或违规内容。 |

### C. 数据看板 (Dashboard)
| 功能名称 | 接口路径 | 请求方法 | 核心逻辑 |
|---|---|---|---|
| 实时指标摘要 | /admin/stats/summary | GET | 返回：累计用户、今日新增日记、活跃用户数。 |
| 流量趋势图 | /admin/stats/trend | GET | 返回：过去 7 天的日活跃度 (DAU) 曲线数据。 |

## 架构师的特别备注：
* 关于“伪推荐”实现：
  在 GET /spots 接口中，我会通过策略模式（Strategy Pattern）编写代码。当前代码分支只跑 orderBy(createTime).desc()。当未来你要接入真正的推荐算法时，我们只需要在 Service 层增加一个实现类，而不需要改动 API 接口定义，这对前端同学非常友好。
* 安全性设计：
  除了注册登录，所有 POST/PUT/DELETE 接口都将强制校验 JWT 有效性。后台管理类的接口 (/admin/**) 会额外经过一层 Role-Based 拦截，确保普通用户无法越权访问。
* 高性能处理：
  对于“数据看板”这种聚合查询，我会建议使用 Redis 存储每日统计结果，而不是每次都去 MySQL 里执行 COUNT(*)，以应对管理端频繁刷新页面的压力。